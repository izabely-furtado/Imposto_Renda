{"name":"Imposto renda","tagline":"Exercício 4 de 8 da Lista de Padrões de Projeto","body":"### Diagrama do Padrão Estrategia\r\n\r\nO diagrama a seguir representa como foi usado o padrão estratégia para a resolução do problema.\r\n\r\n![](https://github.com/izabely-furtado/Imposto_Renda/blob/master/diagramas/Class%20DiagramPadraoStrategy.png?raw=true)\r\n\r\n### Explicação\r\n\r\n**Participantes**\r\n\r\n* **ICalculaImposto**: É uma interface comum para todas as subclasses, ou para todos os algoritmos que são suportados. O Contexto usa essa interface para chamar uma das subclasses CalcImpostoX ou um dos algoritmos definidos.\r\n* **CalculaImpostoStrategy**: A classe concreta que implementa a interface ICalculaImposto e suas subclasses estão definidas de modo a cobrir cada faixa abordada no imposto de renda. \r\n* **ImpostoRenda**: É aquele que vai acessar um dos algoritmos das subclasses de interface ICalculaImposto.\r\n\r\n**Implementação**\r\n\r\nNa classe que acessa os algoritmos em si, foi decidido colocar a lista de estratégias e o salário para facilitar o processo de verificação que ocorre na função **+calcularImpostoRenda()**. Sendo assim na criação já é setadas as faixas possíveis de imposto de renda e o salário a ser conferiso\r\n`\r\npublic class ImpostoRenda{\r\n    List<CalculaImpostoStrategy> estrategias;\r\n    double salario;\r\n    \r\n    ImpostoRenda(double salario){\r\n        //criando as estrategias\r\n        CalcImpostoFaixa1 f1 = new CalcImpostoFaixa1();\r\n        CalcImpostoFaixa2 f2 = new CalcImpostoFaixa2();\r\n        CalcImpostoFaixa3 f3 = new CalcImpostoFaixa3();\r\n        CalcImpostoFaixa4 f4 = new CalcImpostoFaixa4();\r\n        CalcImpostoFaixa5 f5 = new CalcImpostoFaixa5();\r\n        //setando as estrategias\r\n        this.estrategias = new ArrayList();\r\n        this.estrategias.add(f1);\r\n        this.estrategias.add(f2);\r\n        this.estrategias.add(f3);\r\n        this.estrategias.add(f4);\r\n        this.estrategias.add(f5);\r\n        //setando o salario\r\n        this.salario = salario;\r\n    }\r\n\r\n    public double calcularImpostoRenda() {\r\n        double imposto = -1;\r\n        CalculaImpostoStrategy estrategiaUse;\r\n        //adequando o estrategia a ser usada para o salario\r\n        for (CalculaImpostoStrategy estrategia: this.estrategias){\r\n            if (salario >= estrategia.getLimInferior() && this.salario <= estrategia.getLimSuperior()){\r\n                imposto = estrategia.calcularImpostoRenda(this.salario);\r\n            }\r\n        }\r\n        if(imposto == -1){\r\n            throw new UnsupportedOperationException(\"Salário negativo não é considerado\\n\");\r\n        }\r\n        return imposto;\r\n    }\r\n`\r\n\r\nEnquanto isso o as Faixas de Imposto de Renda são criadas da seguinte forma:\r\n\r\nNa Classe abstrata é pedido a inserção de limites e da aliquota\r\n`\r\npublic abstract class CalculaImpostoStrategy implements ICalculaImposto{\r\n    protected double limiteInferior;\r\n    protected double limiteSuperior;\r\n    protected double aliquota;\r\n    \r\n    CalculaImpostoStrategy(double limInferior, double limSuperior, double aliquota){\r\n        this.limiteInferior = limInferior;\r\n        this.limiteSuperior = limSuperior;\r\n        this.aliquota = aliquota;\r\n    }\r\n}\r\n`\r\n\r\nJá numa Faixa é criada da seguinte forma:\r\n\r\n`\r\npublic class CalcImpostoFaixa5 extends CalculaImpostoStrategy{\r\n\r\n    public CalcImpostoFaixa5() {\r\n        super(4271.59, Double.MAX_VALUE, 0.275);\r\n    }\r\n    \r\n}\r\n`\r\n\r\n### Motivações\r\n\r\nEntre os benefícios do padrão Strategy podem-se citar:\r\n\r\n* a reutilização por parte do Contexto que permite escolher entre uma família de algoritmos que possuem funcionalidades em comum; \r\n* os algoritmos em classes Strategy possuem variações do seus algoritmos independentemente do seu contexto, assim é mais fácil utilizá-los, trocá-los, compreende-los e estende-los; \r\n* diminuição ou eliminação da lógica condicional clarificando ainda mais os algoritmos; \r\n* a Strategy permite que se escolham diferentes implementações do mesmo comportamento; utilizando Strategy há uma grande simplificação na classe ao mover variações de um algoritmo para uma hierarquia; \r\n* habilita-se que um algoritmo seja substituído por outro em tempo de execução.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}